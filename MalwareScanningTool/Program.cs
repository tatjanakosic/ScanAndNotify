using AuditManager;
using CertificateManager;
using Common;
using SecurityManager;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IdentityModel.Policy;
using System.IO;
using System.Linq;
using System.Security.Cryptography.X509Certificates;
using System.Security.Principal;
using System.ServiceModel;
using System.ServiceModel.Description;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Xml.Serialization;

namespace MalwareScanningTool
{
    class Program
    {
        static void Main(string[] args)
        {
            string name = Formatter.ParseName(WindowsIdentity.GetCurrent().Name);
            Console.WriteLine(name);

            ServiceHost svc = new ServiceHost(typeof(MalwareScanningTool));
            NetTcpBinding bindingCL = new NetTcpBinding();

            //Windows Authentification
            bindingCL.Security.Mode = SecurityMode.Transport;
            bindingCL.Security.Transport.ClientCredentialType = TcpClientCredentialType.Windows;
            bindingCL.Security.Transport.ProtectionLevel = System.Net.Security.ProtectionLevel.EncryptAndSign;

            //Defining CustomAuthorizationManager as the preffered one.
            //svc.Authorization.ServiceAuthorizationManager = new CustomAuthorizationManager();

            //Defining our principal settings.
            svc.Authorization.PrincipalPermissionMode = PrincipalPermissionMode.Custom;
            List<IAuthorizationPolicy> policies = new List<IAuthorizationPolicy>();
            policies.Add(new CustomAuthorizationPolicy());
            svc.Authorization.ExternalAuthorizationPolicies = policies.AsReadOnly();

            //Audits
            ServiceSecurityAuditBehavior newAudit = new ServiceSecurityAuditBehavior();
            newAudit.AuditLogLocation = AuditLogLocation.Application;
            newAudit.ServiceAuthorizationAuditLevel = AuditLevel.SuccessOrFailure;

            svc.Description.Behaviors.Remove(typeof(ServiceDebugBehavior));
            svc.Description.Behaviors.Add(new ServiceDebugBehavior() { IncludeExceptionDetailInFaults = true });
            svc.Description.Behaviors.Remove<ServiceSecurityAuditBehavior>();
            svc.Description.Behaviors.Add(newAudit);

            svc.AddServiceEndpoint(typeof(Common.IMalwareScanningTool),
                                   bindingCL,
                                   new Uri("net.tcp://localhost:5002/IMalwareScanningTool"));

            svc.Open();

            string srvCertCN = "ids";

            NetTcpBinding bindingIDS = new NetTcpBinding();
            bindingIDS.Security.Transport.ClientCredentialType = TcpClientCredentialType.Certificate;
            X509Certificate2 srvCert = CertManager.GetCertificateFromStorage(StoreName.My, StoreLocation.LocalMachine, srvCertCN);

            EndpointAddress addressIDS = new EndpointAddress(new Uri("net.tcp://localhost:5001/IIntursionDetectionSystem"),
                                      new X509CertificateEndpointIdentity(srvCert));

            //MalwareScanningTool proxy = new MalwareScanningTool(bindingIDS, addressIDS);


            using(MalwareScanningTool proxy = new MalwareScanningTool(bindingIDS, addressIDS))
            {
                // DS
                string srvCertCNN = Formatter.ParseName(WindowsIdentity.GetCurrent().Name);
                string srvCertCNSign = srvCertCNN + "Sign";
                string message = "Porukica";
                X509Certificate2 certificateSign = CertManager.GetCertificateFromStorage(StoreName.My,
                    StoreLocation.LocalMachine, srvCertCNSign);

                X509Store store = new X509Store(StoreName.My, StoreLocation.LocalMachine);
                store.Open(OpenFlags.ReadOnly);

                foreach (var certificate123 in store.Certificates)
                {
                    if (certificate123.Subject.Contains(srvCertCNSign))
                    {
                        store.Close();
                        //Console.WriteLine("da1");

                    }
                }
               
                byte[] signature = DigitalSignature.Create(message, HashAlgorithm.SHA1, certificateSign);

                //proxy.Natpis();
                
                try
                {
                    proxy.SendMessage(message, signature);

                }
                catch(Exception e)
                {
                    Console.WriteLine(e.Message);
                }
                //Console.WriteLine("SendMessage() using {0} certificate finished. Press <enter> to continue ...", srvCertCNSign);
                Console.WriteLine();
                AddCurrentProcessesToWL();
                bool exit = false;
                Alarm alarm = new Alarm();
                DateTime timestamp = new DateTime();
                AlarmCriticality criticality = AlarmCriticality.Information;
                List<Threat> threatList = new List<Threat>();

                while (!exit)
                {
                    Thread.Sleep(10000);

                    string hashFile = FileIntegrityMonitoring.GetHashValue() + "+" + FileIntegrityMonitoring.GetHashOfLogFile();
                    byte[] signatureHash = DigitalSignature.Create(hashFile, HashAlgorithm.SHA1, certificateSign);
                    Console.WriteLine(proxy.CheckFileIntegrity(hashFile, signatureHash));


                    threatList = Scan(threatList);
                    foreach (Threat threat in threatList)
                    {
                        if (threat.TimesDetected >= 3)
                        {
                            criticality = AlarmCriticality.Critical;
                        }
                        else if (threat.TimesDetected == 2)
                        {
                            criticality = AlarmCriticality.Warning;
                        }
                        else if (threat.TimesDetected == 1)
                        {
                            criticality = AlarmCriticality.Information;
                        }
                        timestamp = DateTime.Now;
                        alarm = new Alarm(1, threat.Process.ProcessName, criticality, timestamp);

                        byte[] signatureAlarm = DigitalSignature.Create(message, HashAlgorithm.SHA1, certificateSign);
                        proxy.UpdateIDS(alarm, message, signatureAlarm);
                        //Audit.ThreatDetected(threat.Process.ProcessName, criticality, timestamp);

                        if (criticality == AlarmCriticality.Critical)
                        {
                            Audit.ThreatDetected(threat.Process.ProcessName, criticality, timestamp);
                        }

                        


                    }

                    string s = FileIntegrityMonitoring.GetHashOfLogFile();
                    FileIntegrityMonitoring.SetHashValue(s);

                    Console.WriteLine("Checking for threats.");
                    Console.WriteLine();
                }

                Console.ReadLine();
            }
            
            
        }

        private static void AddCurrentProcessesToWL()
        {
            string whitelistPath = @"..\..\Whitelist.xml";
            XmlSerializer serializer = new XmlSerializer(typeof(List<ConfigurationEntry>));
            List<ConfigurationEntry> entryList = new List<ConfigurationEntry>();
            Process[] processes = Process.GetProcesses();
            //Console.WriteLine(processes.Length);
            if (File.Exists(whitelistPath))
            {
                using (TextReader stream = new StreamReader(whitelistPath))
                {
                    try
                    {
                        entryList = (List<ConfigurationEntry>)serializer.Deserialize(stream);
                    }
                    catch (Exception e)
                    {
                        //Avoiding the empty whitelist exception.
                    }
                }


                int cnt = entryList.Count;

                if (entryList.Count == 0 || entryList == null)
                {

                    entryList = new List<ConfigurationEntry>();

                    for (int i = 0; i < processes.Length; i++)
                    {

                        entryList.Add(new ConfigurationEntry(i, processes[i].ProcessName, new List<string>() { processes[i].StartInfo.UserName }));


                    }

                    using (TextWriter stream = new StreamWriter(whitelistPath))
                    {
                        serializer.Serialize(stream, entryList);
                        Console.WriteLine("Added initial processes to the whitelist.");

                        try
                        {
                            //Audit.ModifyEntrySuccess();
                        }
                        catch (Exception e)
                        {
                            Console.WriteLine(e.Message);
                        }
                    }



                }

                else
                {

                    foreach (Process process in processes)
                    {

                        string username = process.StartInfo.UserName;
                        string processName = process.ProcessName;
                        bool exists = false;
                        bool entryExists = false;
                        foreach (ConfigurationEntry cf in entryList)
                        {

                            if (cf.ProcessName.Equals(processName))
                            {

                                entryExists = true;

                                foreach (string user in cf.Users)
                                {

                                    if (user.Equals(username))
                                    {

                                        exists = true;
                                        break;
                                    }

                                }

                                if (!exists)
                                {

                                    cf.Users.Add(username);
                                    break;
                                }

                            }

                        }

                        if (!entryExists)
                        {

                            entryList.Add(new ConfigurationEntry(++cnt, processName, new List<string>() { username }));


                        }
                    }


                    using (TextWriter std = new StreamWriter(whitelistPath))
                    {
                        serializer.Serialize(std, entryList);
                        //Console.WriteLine("Added initial processes to the whitelist.");

                        try
                        {
                            //Audit.ModifyEntrySuccess();
                        }
                        catch (Exception e)
                        {
                            Console.WriteLine(e.Message);
                        }
                    }


                }
            }
            else
            {
                using (var std = File.Create(whitelistPath)) { 
                    
                    //Creating file
                
                } ;

                for (int i = 0; i < processes.Length; i++) {

                    entryList.Add(new ConfigurationEntry(i,processes[i].ProcessName,new List<string>() { processes[i].StartInfo.UserName}));
                
                
                }


                using (TextWriter stream = new StreamWriter(whitelistPath))
                {
                    serializer.Serialize(stream, entryList);
                    Console.WriteLine("Added initial processes to the whitelist.");

                    try
                    {
                        //Audit.ModifyEntrySuccess();
                    }
                    catch (Exception e)
                    {
                        Console.WriteLine(e.Message);
                    }
                }
            }
        }



        private static List<Threat> Scan(List<Threat> threatList)
        {
            string whitelistPath = @"..\..\Whitelist.xml";

            Process[] duplicateProcesses = Process.GetProcesses();
            List<Process> processes = new List<Process>();

            bool found = false;

            foreach (Process process in duplicateProcesses)
            {
                foreach (Process proc in processes)
                {
                    if (process.ProcessName.Equals(proc.ProcessName))
                    {
                        found = true;
                        break;
                    }
                    found = false;
                }
                if (!found)
                {
                    processes.Add(process);
                }
            }

            XmlSerializer serializer = new XmlSerializer(typeof(List<ConfigurationEntry>));
            List<ConfigurationEntry> entryList = new List<ConfigurationEntry>();

            if (File.Exists(whitelistPath))
            {
                using (TextReader stream =new StreamReader(whitelistPath))
                {
                    try
                    {
                        entryList = (List<ConfigurationEntry>)serializer.Deserialize(stream);
                    }
                    catch (Exception e)
                    {
                        //Avoiding the empty database exception.
                    }
                }

                List<Threat> proxyThreatList = new List<Threat>();
                foreach (Threat threat in threatList)
                {
                    proxyThreatList.Add(threat);
                }

                foreach (Process process in processes)
                {
                    foreach (ConfigurationEntry entry in entryList)
                    {
                        if (process.ProcessName.Equals(entry.ProcessName))
                        {
                            foreach (Threat threat in proxyThreatList)
                            {
                                if (threat.Process.ProcessName.Equals(entry.ProcessName))
                                {
                                    threatList.Remove(threat);
                                }
                            }
                            break;
                        }
                    }
                }

                foreach (Process process in processes)
                {
                    found = false;
                    foreach (ConfigurationEntry entry in entryList)
                    {
                        if (process.ProcessName.Equals(entry.ProcessName))
                        {
                            found = true;
                            break;
                        }
                        found = false;
                    }
                    if (!found)
                    {
                        Console.WriteLine(process.ProcessName);
                        foreach (Threat threat in threatList)
                        {
                            if (threat.Process.ProcessName.Equals(process.ProcessName))
                            {
                                found = true;
                                threat.TimesDetected++;
                                break;
                            }
                        }
                        if (!found)
                        {
                            threatList.Add(new Threat(process, 1));
                        }
                    }
                }
            }

            return threatList;
        }
    }
}
